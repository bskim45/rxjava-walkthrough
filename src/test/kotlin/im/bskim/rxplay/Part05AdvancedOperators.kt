package ktplay

import io.reactivex.Flowable
import io.reactivex.Observable
import org.junit.Test
import java.util.concurrent.Callable
import java.util.concurrent.TimeUnit

/**
 * @author sbalamaci
 */
class Part05AdvancedOperators : BaseTestObservables() {

    @Test
    fun buffer() {
        val numbers = Flowable.interval(1, TimeUnit.SECONDS)

        val delayedNumbersWindow = numbers
                .buffer(5)

        subscribeWithLog(delayedNumbersWindow)
    }

    @Test
    fun simpleWindow() {
        val numbers = Flowable.interval(1, TimeUnit.SECONDS)

        val delayedNumbersWindow = numbers
                .window(5)
                .flatMap { window -> window.doOnComplete { log.info("Window completed") } }

        subscribeWithLog(delayedNumbersWindow)
    }


    @Test
    fun window() {
        val numbers = Flowable.interval(1, TimeUnit.SECONDS)

        val delayedNumbersWindow = numbers
                .window(10, 5, TimeUnit.SECONDS)
                .flatMap { window -> window.doOnComplete { log.info("Window completed") } }

        subscribeWithLog(delayedNumbersWindow)
    }

    /**
     * groupBy splits the stream into multiple streams with the key generated by the function passed as
     * parameter to groupBy
     */
    @Test
    fun groupBy() {
        val colors = Flowable.fromArray("red", "green", "blue",
                "red", "yellow", "green", "green")

        val groupedColorsStream = colors
                .groupBy { v -> v } //identity function
        //                .groupBy(val -> "length" + val.length());

        val colorCountStream = groupedColorsStream
                .flatMap { groupedColor ->
                    groupedColor
                            .count()
                            .map { count -> Pair(groupedColor.key, count) }
                            .toFlowable()
                }

        subscribeWithLog(colorCountStream)
    }

    @Test
    fun bufferWithLimitTriggeredByObservable() {
        val colors = Observable.fromArray("red", "green", "blue",
                "red", "yellow", "#", "green", "green")


        colors.publish<List<String>> { p ->
                    p.filter { `val` -> `val` != "#" }
                            .buffer<String>(Callable { p.filter { `val` -> `val` == "#" } })
                }
                .subscribe { list ->
                    val listCommaSeparated = list.joinToString(",")

                    log.info("List {}", listCommaSeparated)
                }
    }
}
